<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="es">
<head>
<title>1 Ordenamiento Burbuja (Bubblesort)</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="alg_ord.css" media="screen" type="text/css">
</head>

<body>
 <h1>1 Ordenamiento Burbuja (Bubblesort)</h1>

 <div>
  <p class="barra">
    [<a title="Volver a la Página Principal de Algoritmos"
        href="alg_ord.htm">Volver a Algoritmos</a>]
    [<a title="Siguiente: Ordenamiento por Selección" 
        href="seleccion.htm">2 Selección</a>]
  </p>
 </div>

 <!-- Descripción -->
 <a id="descripcion"></a>
 <h2>1. Descripción.</h2>
 <p>Este es el algoritmo más sencillo probablemente. Ideal para empezar. Consiste en
   ciclar repetidamente a través de la lista, comparando elementos adyacentes de dos en
   dos. Si un elemento es mayor que el que está en la siguiente posición se intercambian.
   ¿Sencillo no?
 </p>

 <!-- Pseudocódigo en C -->
 <a id="pseudocodigo"></a>
 <h2>2. Pseudocódigo en C.</h2>

 <!-- Tabla de variables -->
 <table border=1 align=center
  summary="Tabla de Variables: Nombre, tipo y uso de cada varaiable en el algoritmo">
  <caption>Tabla de variables</caption>
  <thead>
   <tr>
    <th>Nombre</th>
    <th>Tipo</th>
    <th>Uso</th>
   </tr>
  </thead>

  <tbody>
   <tr>
    <td>lista</td>
    <td>Cualquiera</td> 
    <td>Lista a ordenar</td> 
   </tr>
   <tr>
    <td>TAM</td>
    <td>Constante entera</td> 
    <td>Tamaño de la lista</td> 
   </tr>
   <tr>    
    <td>i</td>
    <td>Entero</td>
    <td>Contador</td>
   </tr>
   <tr>
    <td>j</td>
    <td>Entero</td> 
    <td>Contador</td> 
   </tr>
   <tr>
    <td>temp</td>
    <td>El mismo que los elementos de la lista</td> 
    <td>Para realizar los intercambios</td> 
   </tr>  
  </tbody> 
 </table> 

 <!-- Listado -->
 <pre class="pseudo"> 
    1. for (i=1; i&lt;TAM; i++)
    2.      for j=0 ; j&lt;TAM - 1; j++)
    3.           if (lista[j] > lista[j+1])
    4.                temp = lista[j];
    5.                lista[j] = lista[j+1];
    6.                lista[j+1] = temp;
 </pre>

 <!-- Ejemplo de ejecución del algoritmo -->
 <a id="ejemplo"></a>            
 <h2>3. Un ejemplo</h2>
 <p>Vamos a ver un ejemplo. Esta es nuestra lista:
 </p>
 <p class=ejemp>4 - 3 - 5 - 2 - 1
 </p>
 <p>Tenemos 5 elementos. Es decir, TAM toma el valor 5. Comenzamos comparando el primero 
   con el segundo elemento. 4 es mayor que 3, así que intercambiamos. Ahora tenemos:
 </p>
 <p class=ejemp><b>3</b> - <b>4</b> - 5 - 2 - 1
 </p>
 <p>Ahora comparamos el segundo con el tercero: 4 es menor que 5, así que no hacemos nada.
   Continuamos con el tercero y el cuarto: 5 es mayor que 2. Intercambiamos y obtenemos:
 </p>
 <p class=ejemp>3 - 4 - <b>2</b> - <b>5</b> - 1
 </p>
 <p>Comparamos el cuarto y el quinto: 5 es mayor que 1. Intercambiamos nuevamente:
 </p>
 <p class=ejemp>3 - 4 - 2 - <b>1</b> - <b>5</b>
 </p>
 <p>Repitiendo este proceso vamos obteniendo los siguientes resultados:
 </p>
 <p class=ejemp>3 - 2 - 1 - 4 - 5
 </p>
 <p class=ejemp>2 - 1 - 3 - 4 - 5
 </p>
 <p class=ejemp>1 - 2 - 3 - 4 - 5
 </p>

 <!-- Optimizaciones -->
 <a id="optimizando"></a>
 <h2>4. Optimizando.</h2>
 <p>Se pueden realizar algunos cambios en este algoritmo que pueden mejorar su rendimiento.
 </p>
 <ul>
  <li><p>Si observas bien, te darás cuenta que en cada pasada a través de la lista un
   elemento va quedando en su posición final. Si no te queda claro mira el ejemplo de
   arriba. En la primera pasada el 5 (elemento mayor) quedó en la última posición, en la
   segunda el 4 (el segundo mayor elemento) quedó en la penúltima posición. Podemos evitar
   hacer comparaciones innecesarias si disminuimos el número de éstas en cada pasada. Tan
   sólo hay que cambiar el ciclo interno de esta manera:</p>   
   <p class="ejemp">for (j=0; j&lt;TAM - <b>i</b>; j++)
   </p>
  </li>  
  <li>Puede ser que los datos queden ordenados antes de completar el ciclo externo.
   Podemos modificar el algoritmo para que verifique si se han realizado intercambios. Si
   no se han hecho entonces terminamos con la ejecución, pues eso significa que los datos
   ya están ordenados. Te dejo como tarea que modifiques el algoritmo para hacer esto
   <b>:-)</b>.
  </li>
  <li>Otra forma es ir guardando la última posición en que se hizo un intercambio, y en la
   siguiente pasada sólo comparar hasta antes de esa posición.
  </li>
 </ul>  

 <!-- Análisis del algoritmo -->
 <a id="analisis"></a>
 <h2>5. Análisis del algoritmo.</h2>
 <p>Éste es el análisis para la versión no optimizada del algoritmo:
 </p>
 <ul>  
  <li><a href="alg_ord.htm#estabilidad">Estabilidad</a>: Este algoritmo nunca intercambia
    <a href="alg_ord.htm#registro">registros</a> con
    <a href="alg_ord.htm#clave">claves</a> iguales. Por lo tanto es <i>estable</i>.
  </li>
  <li><a href="alg_ord.htm#requerimientos">Requerimientos de Memoria</a>: Este algoritmo 
    sólo requiere de una variable adicional para realizar los intercambios.
  </li>
  <li><a href="alg_ord.htm#tiempo_ejecucion">Tiempo de Ejecución</a>: El ciclo interno se
    ejecuta <b>n</b> veces para una lista de n elementos. El ciclo externo también
    se ejecuta <b>n</b> veces. Es decir, la complejidad es n * n = O(<b>n<sup>2</sup></b>).
    El comportamiento del caso promedio depende del orden de entrada de los datos, pero es 
    sólo un poco mejor que el del peor caso, y sigue siendo O(<b>n<sup>2</sup></b>).
  </li>
 </ul>
 <p><b>Ventajas:</b>
 </p>
 <ul>
  <li>Fácil implementación.
  </li>
  <li>No requiere memoria adicional.
  </li>
 </ul>
 <p><b>Desventajas:</b>
 </p>
 <ul>
  <li>Muy lento.
  </li>
  <li>Realiza numerosas comparaciones.
  </li>
  <li>Realiza numerosos intercambios.
  </li>
 </ul>
 <p>Este algoritmo es uno de los más pobres en rendimiento. Si miras la 
   <a href="alg_ord.htm#codigo">demostración</a> te darás cuenta de ello. No es 
   recomendable usarlo. Tan sólo está aquí para que lo conozcas, y porque su sencillez lo
   hace bueno para empezar. Ya veremos otros mucho mejores. Ahora te recomiendo que hagas
   un programa y lo pruebes. Si tienes dudas mira el
   <a href="alg_ord.htm#codigo">programa de ejemplo</a>. 
 </p>

 <div>
  <p class="barra">
    [<a title="Volver a la Página Principal de Algoritmos"
        href="alg_ord.htm">Volver a Algoritmos</a>]
    [<a title="Siguiente: Ordenamiento por Selección" 
        href="seleccion.htm">2 Selección</a>]
  </p>
 </div>
 
 <hr>
 <p class="copyr">©2001 - <a href="mailto:jhida003@pinhue.ufro.cl">Julián
   Hidalgo</a>
 </p>
</body>
</html>
