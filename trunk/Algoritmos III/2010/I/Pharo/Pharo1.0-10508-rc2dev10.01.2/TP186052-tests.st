TestCase subclass: #PruebaIntegracionFunciones	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP186052-tests'!!PruebaIntegracionFunciones methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 5/5/2010 18:55'!testPruebaDos	"Segundo caso de pruebas específicas dadas por la cátedra"	|x f g h|	x := X new.	f := Fibonacci new.	f parametro: x.	g := Factorial new.	g parametro: x.	h := FuncionCompuesta new.	h parametro1: g parametro2: f.	self assert: ((f evaluarEn: 3) = 2).						"f(3) = 2"	self assert: ((f evaluarEn: 8) = 21). 					"f(8) = 21"	self assert: ((g evaluarEn: 3) = 6).						"g(3) = 6"	self assert: ((g evaluarEn: 10) = 3628800).				"g(10) = 3,628,800"	self assert: ((h evaluarEn:4) = 6).						"g(f(4)) = 6"	self should: [g evaluarEn:-2] raise: ArgumentoError. "g(-2) = error"! !!PruebaIntegracionFunciones methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 5/5/2010 18:57'!testPruebaUno	"Primero caso de pruebas específicas dadas por la cátedra"	|constante1 constante2 constante3 constante4 division producto potencia x f g h|	constante1 := Constante new.	constante1 valor:3.	x := X new.	division := Division new.	division parametro1:x parametro2:constante1.	constante2 := Constante new.	constante2 valor:5.	producto :=	Producto new.	producto parametro1:constante2 parametro2:x.		f := Suma new.	f parametro1:producto parametro2:division. "f(x) = 5x + (x/3)"		constante3 := Constante new.	constante3 valor:5.	potencia := Potencia new.	potencia parametro1: constante3 parametro2:x.	constante4 := Constante new.	constante4 valor:7.	g := Resta new.	g parametro1:potencia parametro2:constante4. "g(x) = (5 ^x ) -7"		h := FuncionCompuesta new.	h parametro1: f parametro2: g.		self assert: ((f evaluarEn: 9) = 48).						"f(9) = 48"	self assert: ((f evaluarEn: 0) = 0). 						"f(0) = 0"	self assert: ((g evaluarEn: 2) = 18).						"g(2) = 18"	self assert: ((g evaluarEn: 0) = -6).						"g(0) = -6"	self assert: ((h evaluarEn: 1) = (-32/3)). 					"f(g(1)) = 10.666..."	! !TestCase subclass: #Tests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP186052-tests'!!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/20/2010 15:14'!testArcocoseno	"Pruebas del arcoCoseno"	| f x pi |	x := X new.	f := Arcocoseno new.	f parametro: x.	pi := Float pi.	 "Evaluaciones fuera del dominio de la función"	self should: [f evaluarEn:1.1] raise: ArgumentoError.	self should: [f evaluarEn:-1.1] raise: ArgumentoError.	self should: [f evaluarEn:11.42] raise: ArgumentoError.	self should: [f evaluarEn:-5.51] raise: ArgumentoError.	"Casos ideales"	self assert: ((f evaluarEn:0) = (pi/2)).	self assert: ((f evaluarEn:1) = 0).		self assert: ((f evaluarEn:-1) = pi).! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/20/2010 02:35'!testArcoseno	"Pruebas del Arcoseno"		| f x pi |	x := X new.	f := Arcoseno new.	f parametro: x.	pi := Float pi.	"Evaluaciones fuera del dominio de la función"	self should: [f evaluarEn:1.1] raise: ArgumentoError.	self should: [f evaluarEn:-1.1] raise: ArgumentoError.	self should: [f evaluarEn:2.242] raise: ArgumentoError.	self should: [f evaluarEn:-7.51] raise: ArgumentoError.	"Casos ideales"	self assert: ((f evaluarEn:0) = 0).	self assert: ((f evaluarEn:1) = (pi/2)).		self assert: ((f evaluarEn:-1) = ((-1*pi)/2)).! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 5/5/2010 18:57'!testComposicion	"Pruebas de la composición de funciones"		| f f1 f2 f3 g h i x constante constante2 |	x := X new.	constante := Constante new.	f1 := Producto new.	constante valor:2.	f1 parametro1: constante parametro2: x.	constante2 := Constante new.		constante2 valor:3.	f2 := Suma new.	f2 parametro1: constante2 parametro2: f1.	f3 := Potencia new.	f3 parametro1: f2 parametro2: constante.		f := Suma new.	f parametro1: f3 parametro2: f1.  "f(x) = (3+2x)^2 + (2x)"	self assert: ((f evaluarEn: 2) = (53)). "f(2) = 53"		Transcript clear.	constante := Constante new.	constante valor:3.	x := X new.	h := Producto new.	h parametro1: x parametro2: constante.	f := Seno new.	f parametro: h.	g := Suma new.	g parametro1:x parametro2:constante.	i := FuncionCompuesta new.	i parametro1: f parametro2: g.	self assert: ((i evaluarEn: 8) closeTo: 0.99991186).	! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/20/2010 02:40'!testConstante	"Pruebas de una constante"		| constante |	constante := Constante new.	constante valor: 7.	"Debe devolver siempre el valor constante, sin importar dónde se lo evalúe"	self assert: ((constante evaluarEn: 7) = 7).	self assert: ((constante evaluarEn: -37) = 7).! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/20/2010 02:36'!testCoseno	"Pruebas del coseno"		| f x pi |	x := X new.	f := Coseno new.	f parametro: x.	pi := Float pi.	"Casos ideales"	self assert: ((f evaluarEn: 0) = 1).	self assert: ((f evaluarEn: (pi/2)) closeTo: 0).		"Propiedad periódica del coseno: cos(x) = cos(x+2kpi)"		self assert: ((f evaluarEn:7) closeTo: (f evaluarEn:(7+(4*pi)))).! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/21/2010 13:37'!testDerivada	"Pruebas de la derivada"		| f f1 f2 f3 x constante constante2 e |	constante := Constante new.	constante valor:8.	x := X new.	f := Suma new.	f parametro1: constante parametro2:x. "f(x) = 8 + x"		"f'(x) = 1"	"Al ser constante debe ser siempre uno"	self assert: ((f derivarEn: 12) closeTo: 1).	self assert: ((f derivarEn: -1.5) closeTo: 1).	f:= Potencia new.	f parametro1:x parametro2:constante. "f(x) = x^8"		"f'(x) = 8*x^7"		self assert: ((f derivarEn: 1) closeTo: 8).	self assert: ((f derivarEn: 4) closeTo: 131072).		e := Float e.	constante valor:e.	f:= Logaritmo new.	f parametro1: constante parametro2: x. "f(x) = ln(x)"		"f'(x) = 1/x"		self assert: ((f derivarEn: 2) closeTo: (1/2)).	f1 := Producto new.	constante valor:2.	f1 parametro1: constante parametro2: x.	constante2 := Constante new.		constante2 valor:3.	f2 := Suma new.	f2 parametro1: constante2 parametro2: f1.	f3 := Potencia new.	f3 parametro1: f2 parametro2: constante.		f := Suma new.	f parametro1: f3 parametro2: f1.  "f(x) = (3+2x)^2 + (2x)"	"f'(x) = 4*(3+2x) + 2"		self assert: ((f derivarEn: 2) closeTo: (30)). "f'(2) = 30"! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/21/2010 02:03'!testDivision	"Pruebas de la división"		| f x constante1 constante2 |	x := X new.	constante1 := Constante new.	constante1 valor: 8.	f := Division new.	f parametro1: x parametro2: constante1.	"Caso ideal"	self assert: ((f evaluarEn: 24) = 3).	constante2 := Constante new.	constante2 valor: -4.	f parametro1: constante1 parametro2:constante2.		"Realizo una operación entre constantes"	self assert: ((f evaluarEn:32) = -2). 	self assert: ((f evaluarEn:-11) = -2).		"No se puede dividir por cero"		constante1 valor:0.	f parametro1: x parametro2: constante1.	self should: [f evaluarEn:8.] raise: ArgumentoError.! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/20/2010 14:51'!testFactorial	"Pruebas del factorial de un número"		| f x |	x := X new.	f := Factorial new.	f parametro: x.	 "Evaluaciones en números negativos o no-naturales"	self should: [f evaluarEn:12.1] raise: ArgumentoError.	self should: [f evaluarEn:-1.11] raise: ArgumentoError.	self should: [f evaluarEn:-18] raise: ArgumentoError.	"Casos ideales"	self assert: ((f evaluarEn:0) = 1).	self assert: ((f evaluarEn:1) = 1).		self assert: ((f evaluarEn:15) = 1307674368000).! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/20/2010 14:50'!testFibonacci	"Pruebas de Fibonacci"		| f x |	x := X new.	f := Fibonacci new.	f parametro: x.	 "Evaluaciones en números negativos o no-naturales"	self should: [f evaluarEn:12.1] raise: ArgumentoError.	self should: [f evaluarEn:-1.11] raise: ArgumentoError.	self should: [f evaluarEn:-18] raise: ArgumentoError.	"Casos ideales"	self assert: ((f evaluarEn:0) = 0).	self assert: ((f evaluarEn:1) = 1).		self assert: ((f evaluarEn:10) = 55).! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/21/2010 00:28'!testIntegrales	"Pruebas de la integral"		| f x constante |	constante := Constante new.	constante valor:8.	x := X new.	f := Suma new.	f parametro1: constante parametro2:x. "f(x) = 8 + x"		"F(x) / F'(x) = f(x). F(x) = 8*x + (x^2)/2"		self assert: ((f integrarEntre: 1 y: 2) closeTo: 9.5).	self assert: ((f integrarEntre: -1.5 y: 0) closeTo: 10.875).! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 5/5/2010 00:55'!testInterseccion	"Pruebas de sacar la intersección entre dos funciones"		| f g x constante constante2 lista pi |	pi := Float pi.	x := X new.	constante := Constante new.	constante valor: 2.	f := Potencia new.	f parametro1: x parametro2: constante.	constante2 := Constante new.	constante2 valor:9.	"El 'desde' debe ser más grande que el 'hasta'"	self should: [f interseccionEntre: 10 y: 5 con: x.] raise: RangoError.		lista := f interseccionEntre: -5 y: 5 con: constante2.		"La intersección entre la parábola f(x) = x^2 y la constante 9..."	"...es -3 y 3 en el intervalo dado"	self assert: ((lista at:1) closeTo: (-3)).	self assert: ((lista at:2) closeTo: (3)).	self assert: ((lista size) = 2).		constante := Constante new.	constante valor:2.	"f(x) = 2-x"	f := Resta new.	f parametro1: constante parametro2: x.	lista := f interseccionEntre: 0 y: 5 con: x.	"Intersección de f con la recta y=x es 1"		self assert: ((lista at:1) closeTo: 1).	self assert: ((lista size) = 1).! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/20/2010 16:42'!testIntervalo	"Pruebas de evaluar una función en un intervalo"		| f f1 f2 f3 x constante constante2 lista |	x := X new.	constante := Constante new.	f1 := Producto new.	constante valor:2.	f1 parametro1: constante parametro2: x.	constante2 := Constante new.		constante2 valor:3.	f2 := Suma new.	f2 parametro1: constante2 parametro2: f1.	f3 := Potencia new.	f3 parametro1: f2 parametro2: constante.		f := Suma new.	f parametro1: f3 parametro2: f1.  "f(x) = (3+2x)^2 + (2x)"	"El 'desde' debe ser más grande que el 'hasta'"	self should: [f evaluarEntre: 8 y: 1 conPrecision: 0.8] raise: RangoError . 	lista := f evaluarEntre:1 y: 9 conPrecision:0.5.	self assert: ((f evaluarEn: 1) = (lista at:1)).	self assert: ((f evaluarEn: 1.5) = (lista at:2)).	self assert: ((f evaluarEn: 2) = (lista at:3)).	self assert: ((f evaluarEn: 2.5) = (lista at:4)).	self assert: ((f evaluarEn: 3) = (lista at:5)).	self assert: ((f evaluarEn: 3.5) = (lista at:6)).	self assert: ((f evaluarEn: 4) = (lista at:7)).	self assert: ((f evaluarEn: 4.5) = (lista at:8)).	self assert: ((f evaluarEn: 5) = (lista at:9)).	self assert: ((f evaluarEn: 5.5) = (lista at:10)).	self assert: ((f evaluarEn: 6) = (lista at:11)).	self assert: ((f evaluarEn: 6.5) = (lista at:12)).	self assert: ((f evaluarEn: 7) = (lista at:13)).	self assert: ((f evaluarEn: 7.5) = (lista at:14)).	self assert: ((f evaluarEn: 8) = (lista at:15)).	self assert: ((f evaluarEn: 8.5) = (lista at:16)).	self assert: ((f evaluarEn: 9) = (lista at:17)).		f := Fibonacci new.	f parametro: x.	"La función Fibonacci no se puede evaluar en valores no naturales"	self should: [f evaluarEntre: 1 y: 12 conPrecision: 0.8.] raise: ArgumentoError. 	"La función Fibonacci no se puede evaluar en valores negativos"	self should: [f evaluarEntre: -1 y: 7 conPrecision: 2.] raise: ArgumentoError. 	"En cambio sí se puede aplicar en los naturales"	lista := f evaluarEntre:1 y: 10 conPrecision:1.	self assert: ((lista at:1) = 1).	self assert: ((lista at:2) = 1).	self assert: ((lista at:3) = 2).	self assert: ((lista at:4) = 3).	self assert: ((lista at:5) = 5).	self assert: ((lista at:6) = 8).	self assert: ((lista at:7) = 13).	self assert: ((lista at:8) = 21).	self assert: ((lista at:9) = 34).	self assert: ((lista at:10) = 55).! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/20/2010 03:02'!testLogaritmo	"Pruebas del logaritmo"		| f x constante1 constante2 |	x := X new.	constante1 := Constante new.	constante1 valor: 100.	f := Logaritmo new.	f parametro1: x parametro2: constante1.	"Caso ideal"	self assert: ((f evaluarEn: 10) = 2).	f parametro1: x parametro2: constante1.	"La base no puede ser negativa"	self should: [f evaluarEn:-8.] raise: ArgumentoError.	"La base no puede ser uno"	self should: [f evaluarEn:1.] raise: ArgumentoError.		f parametro1: constante1 parametro2: x.	"El argumento no puede ser negativo"	self should: [f evaluarEn:-4.] raise: ArgumentoError.	"El argumento no puede ser cero"	self should: [f evaluarEn:0.] raise: ArgumentoError.	! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/21/2010 13:22'!testMaximo	"Pruebas de la función Máximo"		| f x constante pi |	constante := Constante new.	constante valor:8.	x := X new.	f := Suma new.	f parametro1: constante parametro2:x. "f(x) = 8 + x"	"Por ser una función estrictamente creciente el máximo valor se alcanza en x=4"	self assert: ( (f maximoEntre:0 y: 4) closeTo: 4).		f := Seno new.	f parametro:x.		pi := Float pi.	"El seno tiene máximos en pi/2 + 2kpi, entre -2 y 2, sólo pi/2"	self assert: ((f maximoEntre: -2 y: 2) closeTo: (pi/2)). 	f := Constante new.	f valor:5.	"Una función constante tiene su primer maximo en el primer punto del intervalo"		self assert: ((f maximoEntre: -8 y: 132) = -8). 	! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/21/2010 13:27'!testMinimo	"Pruebas de la función Mínimo"		| f x constante pi |	constante := Constante new.	constante valor:8.	x := X new.	f := Suma new.	f parametro1: constante parametro2:x. "f(x) = 8 + x"		"Por ser una función creciente el mínimo se alcanza en x=0"	self assert: ((f minimoEntre: 0 y: 4) closeTo: 0). 		f := Seno new.	f parametro:x.		pi := Float pi.	"El seno es periódico y tiene mínimos en -pi/2 + 2kpi, pero como la función"	"devuelve el primer máximo,lo encuentra en x=3*pi/2"	self assert: ((f minimoEntre: 0 y: 5) closeTo: ((3*pi)/2)). 	f := Constante new.	f valor:42.	"Una función constante tiene su primer mínimo en el primer punto del intervalo"		self assert: ((f minimoEntre: -8 y: 132) = -8). ! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/21/2010 02:04'!testPotencia	"Pruebas de la potencia"		| f x constante1 constante2 |	x := X new.	constante1 := Constante new.	constante1 valor: (1/5).	f := Potencia new.	f parametro1: constante1 parametro2: x.	"Caso ideal"	self assert: ((f evaluarEn: (-1)) = 5).	"Cualquier cosa distinta de 0, elevada a 0, da 1"	self assert: ((f evaluarEn: 0) = 1).	constante2 := Constante new. 	constante2 valor: 0.	f parametro1: constante2 parametro2: x.	"Cero elevado a cualquier cosa distinta de 0, da 0"	self assert: ((f evaluarEn: 21) = 0).	constante2 valor: -3.	f parametro1: constante1 parametro2:constante2.		"Realizo una operación entre constantes"	self assert: ((f evaluarEn:32) = 125). 	self assert: ((f evaluarEn:-11) = 125).		"No se puede hacer cero elevado a la cero"		constante1 valor:0.	f parametro1: x parametro2: constante1.	self should: [f evaluarEn:0.] raise: ArgumentoError.! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/20/2010 02:38'!testProducto	"Pruebas del producto"		| f x constante1 constante2 |	x := X new.	constante1 := Constante new.	constante1 valor: 5.	f := Producto new.	f parametro1: x parametro2: constante1.	"Caso ideal"	self assert: ((f evaluarEn: 8) = 40).	f parametro1: constante1 parametro2: x.	"El mismo caso anterior, pero invirtiendo los valores al pasarlos a la funcion"	self assert: ((f evaluarEn: 8) = 40). 	constante2 := Constante new.	constante2 valor: -10.51.	f parametro1: constante1 parametro2:constante2.		"Realizo una operación entre constantes"	self assert: ((f evaluarEn:32) = -52.55). 	self assert: ((f evaluarEn:-11) = -52.55).! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/20/2010 02:39'!testResta	"Pruebas de la resta"		| f x constante1 constante2 |	x := X new.	constante1 := Constante new.	constante1 valor: 5.	f := Resta new.	f parametro1: x parametro2: constante1.	"Caso ideal"	self assert: ((f evaluarEn: 8) = 3).	f parametro1: constante1 parametro2: x.	"El mismo caso anterior, pero invirtiendo los valores al pasarlos a la funcion"	self assert: ((f evaluarEn: 8) = -3).	constante2 := Constante new.	constante2 valor: -10.51.	f parametro1: constante1 parametro2:constante2.		"Realizo una operación entre constantes"	self assert: ((f evaluarEn:32) = 15.51).	self assert: ((f evaluarEn:-11) = 15.51).! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/20/2010 02:43'!testSeno	"Pruebas del seno"		| f x pi |	x := X new.	f := Seno new.	f parametro: x.	pi := Float pi.	"Casos ideales"	self assert: ((f evaluarEn: 0) = 0).	self assert: ((f evaluarEn: (pi/2)) closeTo: 1).		"Propiedad periódica del seno: sen(x) = sen(x+2kpi)"		self assert: ((f evaluarEn:7) closeTo: (f evaluarEn:(7+(4*pi)))).! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/20/2010 02:40'!testSuma	"Pruebas de la suma"		| f x constante1 constante2 |	x := X new.	constante1 := Constante new.	constante1 valor: 5.	f := Suma new.	f parametro1: x parametro2: constante1.	"Caso ideal"	self assert: ((f evaluarEn: 8) = 13).	f parametro1: constante1 parametro2: x.	"El mismo caso anterior, pero invirtiendo los valores al pasarlos a la funcion"	self assert: ((f evaluarEn: 8) = 13).	constante2 := Constante new.	constante2 valor: -10.51.	f parametro1: constante1 parametro2:constante2.		"Realizo una operación entre constantes"	self assert: ((f evaluarEn:32) = -5.51).	self assert: ((f evaluarEn:-11) = -5.51).! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/20/2010 02:45'!testTangente	"Pruebas de la tangente"		| f x pi |	x := X new.	f := Tangente new.	f parametro: x.	pi := Float pi.	"Casos ideales"	self assert: ((f evaluarEn: 0) = 0).	self assert: ((f evaluarEn: (pi/3)) closeTo: 1.73205080).		"Propiedad periódica de la tangente: tan(x) = tan(x+2kpi)"		self assert: ((f evaluarEn:7) closeTo: (f evaluarEn:(7+(4*pi)))).! !!Tests methodsFor: 'as yet unclassified' stamp: 'MarianoRibotta 4/20/2010 14:46'!testVariable	"Pruebas de una variable"		| x |	x := X new.	"Debe devolver siempre el valor pasado"	self assert: ((x evaluarEn: 42) = 42).	self assert: ((x evaluarEn: -5.5) = -5.5).! !